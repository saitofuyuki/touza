#+title: TOUZA/Zbt guide
#+author: SAITO Fuyuki
#+date: <2024-07-24>
#+email: saitofuyuki AT jamstec DOT go DOT jp

* Introduction
*TOUZA/Zbt* (zbt is pronounced as /za-bu-ton/) is a collection of
python interface on *TOUZA* libraries, in particular, GTOOL3 (or
TOUZA/Nio) format accesses.

*TOUZA/Zbt* is maintained by SAITO Fuyuki <saitofuyuki AT jamstec
DOT go DOT jp>.

*TOUZA (楊座)*, MIROC base infrastructure, is a collection of
FORTRAN procedures mainly adopted in MIROC.  See *TOUZA* README
(expected to be in the parent directory) for general instruction of
*TOUZA* collection.

* Installation
Installation of python resources using ~make install~ is disabled by
default.  Rather, it is recommended to install them with ~pip~.

** Installation with pip
The module ~zbt~ depends on the shared library (e.g., ~libtouza.so~),
thus before the installation of ~zbt~, a standard sequence of
~configure~ - ~make~ - ~~make install~ is required.
You must configure with =--enable-shared= argument.

: % cd touza-x.y.z
: % ./configure --enable-shared --prefix=PREFIX --with-build-jmz --enable-nctcdf
: % make
: % make install
: % ls -F PREFIX/lib
: libtouza.a libtouza.la libtouza.so@ libtouza.so.0@ libtouza.so.0.0.0 pkgconfig/

After the normal sequence, a wheel file can be generated by ~make
python-build~ under =zbt= directory:

: % cd zbt
: % make python-build   ## need to be on line due to pip requirement
: % ls dist
: touza_zbt-1.14.3-py3-none-any.whl  touza_zbt-1.14.3.tar.gz
: % . SOMEWHERE/bin/activate # switch to virtual env
: (python3) % python3 -m pip install dist/touza_zbt-1.14.3-py3-none-any.whl

** Installation with deb
Unfortunately, a python package nc-time-axis is not be prepared as
an official debian package, a full functionality of zbt cannot be
supplied.

If you need non-standard calendar axis to plot, you must manually
install the nc-time-axis package:

:  python3 -m pip install --break-system-packages --user nc-time-axis

This deficiency may influence only on plotting with a calendar axis.
In other words, if both axis are not calendar one then plotting will
succeed, even the dataset contains calendar coordinate.

Internally, the time coordinates are represented using
cftime.datetime.  When nc-time-axis is not available, the time
coordinates are converted into numpy.datetime64 (default of xarray).
This conversion fails at non-standard calendar dates and/or those
beyond the certain range
(cf. https://docs.xarray.dev/en/stable/user-guide/time-series.html),
and plotting is aborted.

** Installation with normal configure/make
If you prefer, zbt can be installed by normal ~make install~.
This feature is enabled at ~configure~ time using
=--enable-sub-zbt=yes= argument:

: % cd touza-x.y.z
: % ./configure --enable-shared --prefix=PREFIX --with-build-jmz --enable-nctcdf \
: %             --enable-sub-zbt=yes
: % make
: % make install
: % ls -F PREFIX/lib/python*/site-packages/zbt
: __init__.py  __pycache__/  config.py ....
: % ls -F PREFIX/bin
: ...  zbcont*

** TOUZA Library location
The shared library path is hard-coded in =zbt/zbt/env.py=, which is
automatically generated during make.
When loading of the shared library fails, try one of the following
for manual configuration:

- add the library directory to environment variable =LD_LIBRARY_PATH=
  during execution
- add the library path environment variable =TOUZA_LIBRARY=
  during execution.  The value can be either a file name or a directory.
  For the latter case, ~libtouza.so~ is appended automatically.
- Pass the library path at ~LibTouzaNio~ object construction
  : lib = LibTouzaNio(name='..../lib/libtouza.so')
- (*Deprecated*) pass =--enable-zbt-embed-libdir= argument at
  =configure=.  The library location is hard-coded according to
  =TOUZA= library installation.

Also, you may need to configure =PYTHONPATH= as appropriate.

* Quick start guide
** A simple example (2d plot of a GTOOL3 file)
Two typical variable file (~T2~ and ~q~) are prepared for
demonstration, as well as two GTOOL3 axis-files on longitude and
latitude.
: % ls -F
: GTAXLOC.GGLA128   GTAXLOC.GLON256   T2   q
: % ngtls T2
:  1 T2       17540796H   744 URY16 20010116 120000 GLON256,GGLA128,SFC1
:  2 T2       17541504H   672 URY16 20010215 000000 GLON256,GGLA128,SFC1
:  3 T2       17542212H   744 URY16 20010316 120000 GLON256,GGLA128,SFC1
:  4 T2       17542944H   720 URY16 20010416 000000 GLON256,GGLA128,SFC1
:  5 T2       17543676H   744 URY16 20010516 120000 GLON256,GGLA128,SFC1
:  6 T2       17544408H   720 URY16 20010616 000000 GLON256,GGLA128,SFC1
:  7 T2       17545140H   744 URY16 20010716 120000 GLON256,GGLA128,SFC1
:  8 T2       17545884H   744 URY16 20010816 120000 GLON256,GGLA128,SFC1
:  9 T2       17546616H   720 URY16 20010916 000000 GLON256,GGLA128,SFC1
: 10 T2       17547348H   744 URY16 20011016 120000 GLON256,GGLA128,SFC1
: 11 T2       17548080H   720 URY16 20011116 000000 GLON256,GGLA128,SFC1
: 12 T2       17548812H   744 URY16 20011216 120000 GLON256,GGLA128,SFC1
: % ngtls q
:  1 Q        17540796H   744 URY16 20010116 120000 GLON256,GGLA128,CMIP6P38
:  2 Q        17541504H   672 URY16 20010215 000000 GLON256,GGLA128,CMIP6P38
:  3 Q        17542212H   744 URY16 20010316 120000 GLON256,GGLA128,CMIP6P38
:  4 Q        17542944H   720 URY16 20010416 000000 GLON256,GGLA128,CMIP6P38
:  5 Q        17543676H   744 URY16 20010516 120000 GLON256,GGLA128,CMIP6P38
:  6 Q        17544408H   720 URY16 20010616 000000 GLON256,GGLA128,CMIP6P38
:  7 Q        17545140H   744 URY16 20010716 120000 GLON256,GGLA128,CMIP6P38
:  8 Q        17545884H   744 URY16 20010816 120000 GLON256,GGLA128,CMIP6P38
:  9 Q        17546616H   720 URY16 20010916 000000 GLON256,GGLA128,CMIP6P38
: 10 Q        17547348H   744 URY16 20011016 120000 GLON256,GGLA128,CMIP6P38
: 11 Q        17548080H   720 URY16 20011116 000000 GLON256,GGLA128,CMIP6P38
: 12 Q        17548812H   744 URY16 20011216 120000 GLON256,GGLA128,CMIP6P38
: 13 CMIP6P38        0S     1   UR8 00000101 000000 CMIP6P38,,

Usually GTOOL3 axis-files are prepared as independent files, however,
is it also possible to embed related axis information as additional
records (like file ~q~).

*** Preparation
Set environment variables ~GTAX_PATH~ if you need GTOOL axis files to
access.
: % export GTAX_PATH=:.:/SOMEWHERE/gtool/lib/gt3    # (sh style)
Paths are separated by colon, thus in this case it is decomposed into
empty, =.=, and =/SOMEWHERE/gtool/lib/gt3=.  Empty path is special, to
indicate to apply the internal axis record if found.

*** To begin
: % python3
: >>> import xarray as xr

If installation succeeded, =zbt= backend is appended in the xarray engines:
: >>> xr.backends.list_engines()
: :
: 'zbt': <xrNioBackendEntrypoint>
:   Use TOUZA/Nio(gtool-3.5 extension) files in Xarray
:   Learn more at https://github.com/saitofuyuki/touza}

For some reason, registration of ~zbt~ may be failed.
In this case try below workaround and
use ~zbt.xrnio.open_dataset()~ instead of ~xarray.open_dataset()~
for dataset creation (explained soon).
: >>> import zbt.xrnio as zxr

*** Create ~xarray.Dataset~ object with GTOOL3 file
To create ~Dataset~ instance, just call ~open_dataset()~ method as
other data formats.
: >>> xds0 = xr.open_dataset("T2")         # a file-name argument
: >>> ##  xds0 = zxr.open_dataset("T2")    # when zbt engine do not appears
: # some run-time warning may appear
: >>> xds0
: <xarray.xrNioDataset> Size: 3MB
: Dimensions:  (record: 12, SFC1: 1, GGLA128: 128, GLON256: 256)
: Coordinates:
:   * GLON256  (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128  (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * SFC1     (SFC1) float64 8B 0.0
:   * record   (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
: Data variables:
:     T2       (record, SFC1, GGLA128, GLON256) float64 3MB ...

If gtool-axis information are found, they are automatically registered
as ~xarray~ coordinates.
If not found, they are simply registered as dimensions with index coordinates:
: >>> xds0
: <xarray.xrNioDataset> Size: 3MB
: Dimensions:  (record: 12, SFC1: 1, GGLA128: 128, GLON256: 256)
: Coordinates:
:   * GLON256  (GLON256) float64 2kB 0.0 1.0 2.0 3.0 ... 252.0 253.0 254.0 255.0
:   * GGLA128  (GGLA128) float64 1kB 0.0 1.0 2.0 3.0 ... 124.0 125.0 126.0 127.0
:   * SFC1     (SFC1) float64 8B 0.0
:   * record   (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
: Data variables:
:     T2       (record, SFC1, GGLA128, GLON256) float64 3MB ...
In this example, axis information along =SFC1= is not found, thus it
is regarded as index coordinate of length 1 (which is actually
equivalent to the official =GTAXLOC.SFC1=).

If gtool-axis information is embedded as records,
the records are also regarded as data variables.
: >>> xds1 = xr.open_dataset("q")
: >>> ##  xds1 = zxr.open_dataset("q")    # when zbt engine do not appears
: # some run-time warning may appear
: >>> xds1
: <xarray.xrNioDataset> Size: 120MB
: Dimensions:     (record~0: 12, CMIP6P38~0: 38, GGLA128: 128, GLON256: 256,
:                  record~1: 1)
: Coordinates:
:   * CMIP6P38~0  (CMIP6P38~0) float64 304B 1e+03 975.0 950.0 ... 2.0 1.0 0.4
:   * GLON256     (GLON256) float32 1kB 0.0 1.406 2.812 ... 355.8 357.2 358.6
:   * GGLA128     (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * record~0    (record~0) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:0...
:   * record~1    (record~1) object 8B 0000-01-01 00:00:00
: Data variables:
:     Q           (record~0, CMIP6P38~0, GGLA128, GLON256) float64 120MB ...
:     CMIP6P38~1  (record~1, CMIP6P38~0) float64 304B ...
Due to the design of TOUZA/Nio library to adjust the data structure to
NetCDF, some variables are renamed internally (like =CMIP6P38~0=).

The GTOOL3 file is analyzed into a netCDF-like structure.  In this
case, 12 records are interpreted as time-slices of one 3-dimension
variable, creating a 4-dimension variable of shape =(12,1,128,256)=
(~T2~) and =(12,38,128,256)= (~q~).
Dimensions which the module can find the corresponding GTOOL3 axis
file (in this case, =GTAXLOC.GLON256=, =GTAXLOC.GGLA128=,
=GTAXLOC.CMIP6P38=) are
automatically converted into ~xarray~ coordinates.  You may need valid
=GTAX_PATH= environment variable to find the axis files.

The time coordinates (named as =record=) are parsed as array of
~cftime.datetime~ objects (merely denoted as =object= above) in the
above case.  This feature is achieved if python package
=nc-time-axis= is available.

If not, they are parsed as array of numpy.datetime64 objects, as follows:
: >>> xds1
: <xarray.xrNioDataset> Size: 120MB
: Dimensions:   (record: 12, CMIP6P38: 38, GGLA128: 128, GLON256: 256)
: Coordinates:
:   * GLON256   (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128   (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * CMIP6P38  (CMIP6P38) float64 304B 1e+03 975.0 950.0 925.0 ... 2.0 1.0 0.4
:   * record    (record) datetime64[ns] 96B 2001-01-16T12:00:00 ... 2001-12-16T...
: Data variables:
:     Q         (record, CMIP6P38, GGLA128, GLON256) float64 120MB ...

Due to the limit of =numpy.datetime64= class,
non-standard calendars or for dates before year 1678 or after year 2262
cannot be represented, thus dataset generation fails.
: >>> ds2 = xr.open_dataset("T_nonstd_calendar")
: :
: zbt[WARNING] <xrnio> Out of bounds nanosecond timestamp: 10-01-16 12:00:00
: :
: RuntimeError: Failed at calendar conversion to <class 'numpy.datetime64'>.
In order to read such files, you need to either install nc-time-axis
package or edit TIME, DATE, etc attributes with ~ngtick~.

You can control calendar property at ~open_dataset()~, with special
argument ~calendar~.

: ### Force numpy.datetime64 instance if valid.
: >>> nds0 = xr.open_dataset("T2", calendar='numpy')

Calendar-kind is automatically detected.
For most cases it is sufficient, but if you are not satisfied with the
automatic detection, you can set the calendar-kind targets as:
: ### set calendar-kind candidates
: >>> nds0 = xr.open_dataset("T2", calendar=('360_day', 'all_leap', ))
Calendar-kind is check through the dataset, and the leftmost kind
which satisfies the TIME/DATE properties correspondence is selected.

The default calendar-kinds to check can be shown with
~calendar_epoch.keys()~ in ~zbt.dsnio~ package.
: >>> import zbt.dsnio as znio
: >>> znio.calendar_epoch.keys()
: dict_keys(['proleptic_gregorian', '360_day', 'noleap', 'all_leap',
: 'julian', 'gregorian', 'standard'])

Please do not confuse ~proleptic_gregorian~ with ~gregorian~.
Indeed, the former corresponds to ~gregorian~ kind in =ngtick=.
: % ngtick -h
: :
:     CAL : gregorian(default), noleap, all_leap, 360_day, julian

*** Dataset attributes
You can examine =dims=, =coords=, =data_vars= attributes of the
=Dataset= object.
: >>> xds0.dims
: FrozenMappingWarningOnValuesAccess({'record': 12, 'SFC1': 1, 'GGLA64': 64, 'GLON128': 128})
: >>> xds0.coords
: Coordinates:
:   * GLON256  (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128  (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * SFC1     (SFC1) float64 8B 0.0
:   * record   (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
:
: >>> xds0.data_vars
: Data variables:
:     T2       (record, SFC1, GGLA128, GLON256) float64 3MB ...

*** DataArray objects
Use dictionary or dot indexing to pull out Dataset variables as
DataArray objects.

: >>> T2 = xds0['T2']
: >>> T2
: <xarray.xrNioDataArray 'T2' (record: 12, SFC1: 1, GGLA128: 128, GLON256: 256)> Size: 3MB
: [393216 values with dtype=float64]
: Coordinates:
:   * GLON256  (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128  (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * SFC1     (SFC1) float64 8B 0.0
:   * record   (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
: Attributes: (12/67)
:     _nio_recdim:  record
:     units:        K
:     long_name:    2m temperature
:     IDFM:                     9010
:     DSET:         ms11sw_dbg
:     ITEM:         T2
:     ...           ...
:     CDATE:        ('20240621 143312', '20240621 145543', '20240621 152044', '...
:     MSIGN:        MIROC
:     SIZE:                    32768
Attributes are defined according to the GTOOL3 file headers.
Three special attributes are defined: =units=, =long_name=, and
=_nio_recdim=.  The first two attributes are used in ~xarray~ and the
last one is used in ~zbt.xrnio~ internally.
Attributes of GTOOL3 headers from all the corresponding records are
collected.  Unique values are defined as single one, otherwise as
tuple.  In the above example, the value corresponding to CDATE is a
tuple of number of the records.

*** Slicing and indexing
Slicing and indexing can be examined:
: >>> sel = T2[1]   # extract record 1 (counting from 0)
: >>> sel
: <xarray.xrNioDataArray 'T2' (SFC1: 1, GGLA128: 128, GLON256: 256)> Size: 262kB
: [32768 values with dtype=float64]
: Coordinates:
:   * GLON256  (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128  (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * SFC1     (SFC1) float64 8B 0.0
:     record   object 8B 2001-02-15 00:00:00
: Attributes: (12/67)
:     _nio_recdim:  record
:     units:        K
:     long_name:    2m temperature
:     IDFM:                     9010
:     DSET:         ms11sw_dbg
:     ITEM:         T2
:     ...           ...
:     CDATE:        ('20240621 143312', '20240621 145543', '20240621 152044', '...
:     MSIGN:        MIROC
:     SIZE:                    32768
: >>> sel.shape
: (1, 128, 256)
Slice with stride does not work, which is reserved for a future development.

*Caution*: important change from version 1.14.3.
The feature of attribute slicing accoring to record slicing are
deleted.  Instead, =nio= accessor is introduced to deal with attribute
slicing.  To be documented.

The Ellipsis literal (=...=) can be used for slicing (only once),
which is regarded as full spanning over all the omitted dimensions.
Also, missing slicing, less than the ranks of data shape, are regard
as full spanning after final specification.  Thus all the slicing
below are identical:
: >>> T2[0].coords
: # T2[0,:].coords
: # T2[0,:,:,:].coords
: # T2[0,...].coords
: # T2[0,...,:].coords
: Coordinates:
:   * GLON256  (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128  (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * SFC1     (SFC1) float64 8B 0.0
:     record   object 8B 2001-01-16 12:00:00

Slicing (except for striding) follows NumPy method, where integer =i=
slicing is different with =i:i+1=:

: >>> T2[0].shape
: (1, 64, 128)          # first dimension is deleted
: >>> T2[0:1].shape
: (1, 1, 64, 128)       # first dimension survives
: >>> T2[0:1].coords
: Coordinates:
:   * GLON256  (GLON256) float32 1kB 0.0 1.406 2.812 4.219 ... 355.8 357.2 358.6
:   * GGLA128  (GGLA128) float64 1kB 88.93 87.54 86.14 ... -86.14 -87.54 -88.93
:   * SFC1     (SFC1) float64 8B 0.0
:   * record   (record) object 8B 2001-01-16 12:00:00

*** Simple plotting using ~xarray~ and ~matplotlib~
~zbt.xrnio~ only provides the backend for GTOOL3 (TOUZA/Nio) format
files.  Therefore, all (or most of) the ~xarray~ methods should work.
: >>> import matplotlib.pyplot as plt
: :
: >>> sel = T2[0]
: >>> fig, ax = plt.subplots()
: >>> sel.plot(ax=ax)
: <matplotlib.collections.QuadMesh at 0x7fbc7db6ff80>
: >>> plt.show()
#+CAPTION: Plot demonstration 1, using xarray.
#+NAME:   fig:demo_01
[[./doc/demo01.png]]

: >>> sel = T2[0,0]  ## need to select a pure 2d-field
: >>> fig, ax = plt.subplots()
: >>> ax.contourf(sel)
: <matplotlib.contour.QuadContourSet object at 0x7fb87d1290a0>
: >>> plt.show()
#+CAPTION: Plot demonstration 2, using matplotlib.
#+NAME:   fig:demo_02
[[./doc/demo02.png]]

See https://docs.xarray.dev/ for ~xarray~ reference.
See https://matplotlib.org/stable/ for ~matplotlib~  reference.

** Support of non-dimension coordinates (experimental)
*The features below are experimental, which is subject to be
redesigned in later releases.*

Typically, a tripolar field has been processed with dummy GTOOL3 axis
files on the longitude and latitude.  Now zbt accepts an extension of
GTOOL3 axis files of multiple dimension.

The extended axis files are named as same as traditional ones.
:   1 OCLONTPT360        0S     0   UR8 00000101 000000 OCLONTPT360,OCLATTPT256,
: % ngtls -n somewhere/GTAXLOC.OCLONTPT360
:   1 OCLONTPT360        0S     0   UR8 00000101 000000  1:360    1:256    1:1
: % ngtls somewhere/GTAXLOC.OCLATTPT256
:   1 OCLATTPT256        0S     0   UR8 00000101 000000 OCLONTPT360,OCLATTPT256,
: % ngtls -n somewhere/GTAXLOC.OCLATTPT256
:   1 OCLATTPT256        0S     0   UR8 00000101 000000  1:360    1:256    1:1
They are both simple two dimension files to store corresponding
longitude/latitude for each gridpoint.

When extended axis files are searchable, dataset is parsed as follows:
: >>> import xarray as xr
: >>> xds = xr.open_dataset('samples/tripolar_field')
: >>> xds
: <xarray.xrNioDataset> Size: 6MB
: Dimensions:      (record: 12, OCDEPT63: 1, OCLATTPT256: 256, OCLONTPT360: 360)
: Coordinates:
:     OCLONTPT360  (OCLATTPT256, OCLONTPT360) float64 737kB ...
:     OCLATTPT256  (OCLATTPT256, OCLONTPT360) float64 737kB ...
:   * OCDEPT63     (OCDEPT63) float64 8B 0.0
:   * record       (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
: Data variables:
:     TO           (record, OCDEPT63, OCLATTPT256, OCLONTPT360) float32 4MB ...

If traditional single-dimension axis files (the identical basenames)
are found earlier, then they are adopted instead:
: >>> xds
: <xarray.xrNioDataset> Size: 4MB
: Dimensions:      (record: 12, OCDEPT63: 1, OCLATTPT256: 256, OCLONTPT360: 360)
: Coordinates:
:   * OCLONTPT360  (OCLONTPT360) float32 1kB -299.5 -298.5 -297.5 ... 58.5 59.5
:   * OCLATTPT256  (OCLATTPT256) float32 1kB -88.0 -85.75 -85.25 ... 89.24 89.58
:   * OCDEPT63     (OCDEPT63) float32 4B 1.0
:   * record       (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
: Data variables:
:     TO           (record, OCDEPT63, OCLATTPT256, OCLONTPT360) float32 4MB ...

Thanks to ~xarray~ and ~matplotlib~, these coordinates are used
automatically.
: >>> xds['TO'][0,0].plot()
: >>> plt.show()

#+CAPTION: Demonstration of a tri-polar field plot, with non-dimension coordinates
#+NAME:   fig:demo_tp0.png
[[./doc/demo_tp0.png]]

#+CAPTION: Demonstration of a tri-polar field plot, with traditional axis files
#+NAME:   fig:demo_tp1.png
[[./doc/demo_tp1.png]]

* Description of TOUZA/Zbt commands
** ~zbcont~ - a (sample) command of contour plot
*** Deficiencies
**** Locked alt-key
Due to an unknown reason, sometimes mouse clicking does not work as
expected.  It seems that it occurs when an alt-key press detected at
some stage is not cleared.  If you observe mouse clicking dose not
works, press alt-key once and retry mouse.

**** Cyclic coordinate
**** Longitude coordinate (experimental ~cartopy~ feature)
*** help
: zbcont [OPTIONS...] FILE [FILE...]

Usage is shown by =zbcont --help=:

: % zbcont --help
: usage: zbcont [-h] [--verbose] [--quiet] [--debug] [--log-level LEVEL]
:               [--log-file FILE] [--force] [--no-decode_coords] [-c SPEC]
:               [-C SPEC] [-M [[METHOD]/][CMAP[/CMAP..]][+ALPHA]] [-N NORM]
:               [-r [LOW][:[HIGH]]] [-v VAR[,VAR...]]
:               [-d DIM/SELECTION[,...]] [-D COORDINATE[/SELECTION][,...]]
:               [-p COORDINATE[,...]] [-o FILE] [--multi-pdf]
:               [--no-multi-pdf] [-i] [-m MAP-SPECS] [-P PROJECTION] [-W]
:               [-L LAYOUT[/OPTIONS...]] [-g [W][,[H]]]
:               [--aspect NUMBER|equal|auto] [--calendar FLAGS[,...]] [-F]
:               [FILE[/SPEC] ...]
:
: positional arguments:
:   FILE[/SPEC]           files, possibly with specifiers
:
: options:
:   -h, --help            show this help message and exit
:   --verbose             Be verbose
:   --quiet, --silent     Be quiet
:   --debug               show debug information
:   --log-level LEVEL     logging level
:   --log-file FILE       file for logging
:   --force               overwrite outputs
:   --no-decode_coords    skip auto coordinate inclusion
:   -c, --contours SPEC   contour intervals or levels specification
:   -C, --colors SPEC     color intervals or levels specification.
:   -M, --color-method [[METHOD]/][CMAP[/CMAP..]][+ALPHA]
:                         coloring method and colormap
:   -N, --color-norm NORM
:                         norm for coloring
:   -r, --range [LOW][:[HIGH]]
:                         data range to draw
:   -v, --variables VAR[,VAR...]
:                         variable filter
:   -d, --dimensions DIM/SELECTION[,...]
:                         coordinate clipping
:   -D, --draw COORDINATE[/SELECTION][,...]
:                         figure coordinate clipping
:   -p, --plot COORDINATE[,...]
:                         figure coordinates
:   -o, --output FILE     output filename
:   --multi-pdf
:   --no-multi-pdf
:   -i, --interactive     interactive mode
:   -m, --map MAP-SPECS   map overlay
:   -P, --projection PROJECTION
:                         map projection
:   -W, --each-file       Create figure for each file
:   -L, --layout LAYOUT[/OPTIONS...]
:                         figure layout (reserved)
:   -g, --geometry [W][,[H]]
:                         figure geometry
:   --aspect NUMBER|equal|auto
:                         aspect ratio of figure scaling
:   --calendar FLAGS[,...]
:                         calendar options
:   -F, --fortran         turn-on fortran style indexing (reserved)
:
: contour spec
:  * contour specification
:    INTERVAL[/....]      contour intervals (e.g., -c10/20)
:    NUMBER:[...]         number of contour levels (e.g., -c16:)
:    LEVEL,[...]          explicit contour levels (e.g., -c133,)
:
:  * color specification
:    INTERVAL
:    NUMBER:
:    LEVEL,[...]
:
:  * color norms
:    {linear(li) sym (sy) log(lo) symlog(sl) asinh (as) twoslope(ts)}
:
:  * color methods
:    {contour(c) contourf(f) pcolormesh(p)}
:
:  * colormaps
:    default: viridis Greys binary PiYG twilight Pastel1 flag
:    seq0: viridis plasma inferno magma cividis
:    seq1: Greys Purples Blues Greens Oranges Reds YlOrBr YlOrRd OrRd PuRd
:          RdPu BuPu GnBu PuBu YlGnBu PuBuGn BuGn YlGn
:    seq2: binary gist_yarg gist_gray gray bone pink spring summer autumn winter
:          cool Wistia hot afmhot gist_heat copper
:    div: PiYG PRGn BrBG PuOr RdGy RdBu RdYlBu RdYlGn Spectral coolwarm
:         bwr seismic
:    cyclic: twilight twilight_shifted hsv
:    qual: Pastel1 Pastel2 Paired Accent Dark2 Set1 Set2 Set3 tab10 tab20
:          tab20b tab20c
:    misc: flag prism ocean gist_earth terrain gist_stern gnuplot gnuplot2 CMRmap cubehelix
:          brg gist_rainbow rainbow jet turbo nipy_spectral gist_ncar

*** simple usage
Try =zbcont= with GTOOL3 format file(s) as command-line parameter:

: % zbcont q T
: (1) 0:q <0:Q> [0, 0, :, :]
: >
One window is opened to plot the contour of a 2d slice of the first
input file.
Using =-W= option, window is created for each file.
: % zbcont -W q T
: (1) 0:q <0:Q> [0, 0, :, :]
: (2) 0:T2 <0:T2> [0, 0, :, :]
: >

Actually, ~zbcont~ is implemented over ~xarray~ package, thus
files with non-GTOOL formats (e.g., netCDF4) can be also specified.
: % zbcont file.nc
: (1) 0:file.nc <0:T> [0, :, :]
: >
Most features are optimized for GTOOL3/Nio files, however, other
formats can be plotted seamlessly.

The first plot is the innermost 2d slice of the input file.
When the focus is on the plot window, space and backspace keys turn
the slice one index forward and backward, respectively:
: # pressing space-key forward one step
: (1) 0:q <0:Q> [0, 0, :, :]
: (1) 0:q <0:Q> [0, 1, :, :]
: (1) 0:q <0:Q> [0, 2, :, :]
: :
: (1) 0:q <0:Q> [0, 37, :, :]
: (1) 0:q <0:Q> [1, 0, :, :]
: (1) 0:q <0:Q> [1, 1, :, :]
:
: # pressing backspace-key backward one step
: (1) 0:q <0:Q> [1, 1, :, :]
: (1) 0:q <0:Q> [1, 0, :, :]
: (1) 0:q <0:Q> [0, 37, :, :]
: :

A left/right click on the coordinate label changes the plot coordinate
with skipping the other coordinate (a gray rectangle is shown when the
pointer is on the label). In the above case, left clicking turns the
coordinate as:
: record <- CMIP6P38 <- GGLA128 <- GLON256
while right clicking turns it reversed:
: record -> CMIP6P38 -> GGLA128 -> GLON256
A middle click on either the coordinate transpose the coordinate.  In
other words, =[GGLA128, GLON256]= plot is changed into =[GLON256, GGLA128]= plot.

If the mouse pointer is on a region between a figure spine and tick
labels (which is referred to as merely `spine' hereafter), a red guide
line is shown on the spine and figure either horizontally or
vertically.
When either guide line is shown, left clicking on the spine changes
the slicing along the guide line.
If a figure is shown over the coordinate =GLON256= (horizontal) and
=GGLA128= (vertical), and the horizontal guide line is shown at 60
degree, left clicking replace the vertical coordinate into next
coordinate (=CMIP6P38= in this case) and choose the nearest index of
=GGLA128= as 60 degree (59.5323, in this case).  No interpolation is
performed.

Middle clicking on a spine region reverse the coordinate.
Right clicking on a spine region change the coordinate norm.

Colorbars are automatically chosen according to ~xarray~
specification: default are =viridis= and =RdBu_r= colormaps for
sequential and diverging field, respectively.
~zbcont~ has two-level grouping of colormaps which can switch
interactively.  Left clicking on colorbar turn the colormap with a
current group, while right clicking on colorbar turn the colormap
group.
Visit [[https://matplotlib.org/stable/users/explain/colors/colormaps.html][Choosing Colormaps in Matplotlib]] for colormaps grouping.
A middle on the colorbar reverses the color direction.

A range of colorbar is automatically chosen to cover the plotting
(plotted) field.  More precisely, by default, each variable shares the
colormap range to be updated to cover the full range of slices that
already plotted.  In this case, at first, the color range is chosen to
cover the slice =[0,0,:,:]=.  At next slice to show, the range is
updated to cover =[0,0:1,:,:]=.  It means that the range is not reset
if the slice go backward.  In this case, after showing =[0,0,:,:]= and
=[0,1,:,:]=, colormap of the second plot of the slice =[0,0,:,:]= is
still cover the range of =[0,0:1,:,:]=.

Middle clicking on the colorbar spine (not colorbar itself) toggles
the lock of the colormap range.

Colorbar has also spine region.  Right clicking on a colorbar spine
changes the colorbar norm (linear, log, symlog, atanh, twoslope).
Left clicking is reserved for adding contour lines (not yet implemented).

Sometimes the figure may contain strange artifacts (e.g., immortal
guidelines).   This can happen at some timing of certain combination
of mouse pointers and slice turning and/or other conditions.
If you encounter such situation, press '.' key to redraw the current
slice.

To quit the program, press 'q' key.
*** command-line arguments
**** contour line option (=--contours=, =-c=)
Full specification is as follows:

: --contours=<spec>[[/:]<spec>....]
: <spec> ::  <number>  or <number>,<number>...

Multiple =<spec>= is separated by colon or slash, and =<spec>= is
either single number or comma-separated list of numbers.

Contour parameters such as line widths are defined for each =<spec>=.
As default, different line widths are defined for the first four
=<spec>=, and after that the final options are reused.

If <spec> is comma-separated list, it is interpreted as explicit
contour levels to plot.  The comma is mandatory for this
interpretation, so in order to plot single explicit contour,
it must be set as =CONTOUR,= (the final comma).

Separator, either colon or slash is significant to interpreted the
meaning of single number.  If separator between items or one after
an item is colon, the number is interpreted as number of maximum bins
to divide the range. Otherwise, i.e., if the separator is slash or
none, it is interpreted as fixed contour interval (More precisely, the
former adopts ~matplotlib.ticker.MaxNLocator~ while the latter
does ~matplotlib.ticker.MultipleLocator~).  Similar to comma, colon is
mandatory for correct interpretation, such that it must be set as
=NUMBER:=.

Empty =<spec>= is not accepted.  Instead, use single =0= to skip the
option set.

The contours by final <spec> are annotated.  You can fine control to
annotate using single =0=.

To summarise, the following examples may help.

: --contours=0
:      no contour

: --contours=10
:      contour intervals of 10  (annotated)

: --contours=10/0
:      contour intervals of 10  (not annotated)

: --contours=20:
:      maximum 20 contour bins (annotated)

: --contours=10/20
:      contour intervals of 10 with option set 0
:      contour intervals of 20 with option set 1  (annotated)

: --contours=10:20
:      maximum 10 contour bins with option set 0
:      contour intervals of 20 with option set 1   (annotated)

: --contours=10:20:
:      maximum 10 contour bins with option set 0
:      maximum 20 contour bins with option set 1   (annotated)

: --contours=100,
:      contour line at 100  (annotated)

: --contours=100,200
:      contour line at 100,200  (annotated)

: --contours=100,200:300,400
: --contours=100,200/300,400
:      contour line at 100,200 with option set 0
:      contour line at 300,400 with option set 1  (annotated)

: --contours=0/10/20:100,200
:       0        no contour with option set 0
:       10       contour intervals of 10 with option set 1
:       20:      totally 20 contours with option set 2
:       100,200  draw contour lines at 100, 200 with option set 3 (annotated)

**** fill-color option (=--colors=, =-C=)
Discrete color map plotting can be achieved using =--colors= option.
The specification is the same as =--contours= option, except that only
one set can be supplied.

Thus =--colors= is set as either of the three forms:

: --colors=<interval>
Fill color with =<interval>= interval.

: --colors <level>,[<level>[,...]]
Fill color with specific levels.  The separator comma is mandatory.

: --colors <number>:
Fill color with =<number>= levels maximum.
The separator colon is mandatory.

**** coloring methods (=--color-method=, =-M=)
Coloring method, colormaps, and color alpha (transparency) can be
specified with =--color-method= argument.

: --color-method=[<method>][/][<cmap>/...][+<alpha>]

The number after =+= is interpreted as optional alpha parameter
(default as 1).
String before =+= is decomposed into tokens by slash.  The first token
is special.  The second and later tokes are always interpreted as
colormaps.
The first token is interpreted as a coloring method if succeeded,
otherwise as a colormap.

Three methods are prepared: pcolormesh, contourf, and contour,
which can be abbreviated as p, f, c, respectively.

List of available colormaps are shown with help commands.
Colormaps can be specified either by name (=viridis=, =RdBu=) or by
group (=default=, =seq0=).  Setting named colormap corresponds to
insertion into the default group, while setting colormap group limits
available group to choose interactively.
**** colormap norm (=--color-norm=, =-N=)
Default colormap norm is linear.  You can change the behaviour with
=--color-norm= options.

:  --color-norm=<norm>[,<norm>...]

Multiple norms can be specified, which limit the available norms to
choose interactively.

Available norms are:
| <norm>   | abbrev |                          | option                          |
| linear   | li     | linear                   |                                 |
| sym      | sy     | linear, symmetric at 0   | sym/<origin>                    |
| log      | lo     | logarithmic              |                                 |
| symlog   | sl     | symmetric logarithmic    | symlog/<threshold>/<min or max> |
| asinh    | as     | arcsinh                  |                                 |
| twoslope | ts     | two different slope at 0 | twoslope/<origin>               |

**** range clipping (=--range=, =-r=)
:  --range [<low>][:[<high>]]
The value smaller than =<low>= or greater than =<high>= is ignored to
plot contour, and is clipped for colormap.
**** dimension clipping (=--dimensions=, =-d=)
:  --dim <dim>/<element>
:  --dim <dim>/[<low>][:[<high>]]
Extract single =<element>= along =<dim>= or clip along dimension
=<dim>= with the index range of =<low>:<high>=.
The dimension name =<dim>= should be a coordinate name or index.

: % zbcont --dim  record/10:20   # limit the record dimension as 10:20
: % zbcont --dim  GLON128/5      # extract section along index 5 of GLON128
: % zbcont --dim  0/10:20        # limit the first dimension as 10:20
: % zbcont --dim=-1/10:20        # limit the last dimension as 10:20
:                                # Need = separator when the index is negative,
:                                # otherwise it is regarded as an independent argument.

Dimension clipping is performed at file reading.  The elements outside
cannot be accessed during execution, which is different from the
behavior of =--draw= argument.
**** draw range (=--draw=, =-D=)
Similar to clipping by =--dimensions=, except for the clipping is
interpreted as initial view range.  The elements outside may be
accessed during execution.
**** variable filter (=--variables=, =-v=)
:  --variables <var>[,....]
List of =<var>= to draw, the others are ignored.
**** figure coordinate (=--plot=, =-p=)
:  --plot [VERTICAL][,[HORIZONTAL]]

: % zbcont --plot record    # change the vertical coordinate as record
: % zbcont --plot ,record   # change the horizontal coordinate as record
: % zbcont --plot 0,-1      # change the vertical and horizontal coordinate
:                           # as the first and the last, respectively
***** (experimental) Plot with non-dimension coordinates
It is possible an data array to have non-dimension coordinates in
addition to dimension coordinates.  For example, the following variable =tas=
is originally defined on rotated longitude/latitude (=rlon=/=rlat=) as
array dimension:
: >>> :
: >>> tas
: <xarray.DataArray 'tas' (time: 120, height: 1, rlat: 327, rlon: 326)> Size: 51MB
: [12792240 values with dtype=float32]
: Coordinates:
:   * time     (time) datetime64[ns] 960B 2006-01-16 ... 2015-12-16
:   * rlon     (rlon) float64 3kB -17.65 -17.55 -17.45 ... 14.65 14.75 14.85
:   * rlat     (rlat) float64 3kB -15.8 -15.7 -15.6 -15.5 ... 16.5 16.6 16.7 16.8
:     lon      (rlat, rlon) float64 853kB ...
:     lat      (rlat, rlon) float64 853kB ...
In addition, there are two non-dimension coordinates, =lon=/=lat=,
which are /physical/ coordinate in ~xarray~ terminology[fn:: Please do
not be confused by the usage of terms
/physical/ and /logical/.  The former corresponds to how the elements
are interpreted in the real-world placements,
while the latter does to how we stored in memory, under the ~xarray~
terminology.  It is different from the style when we represent, e.g.,
a physical or logical record of storage.
Please see [[https://docs.xarray.dev/en/stable/examples/multidimensional-coords.html][Working with Multidimensional Coordinates]] for detail.]
geographical coordinates as functions of =rlon=
and =rlat=.  By default, plotting are performed using the dimension
coordinate =rlon=/=rlat=.  Figure coordinate argument =--plot= can
control this feature, by:
: % zbcont --plot lat,lon datafile
The plot may not always succeed:  too much irregular distribution of
the physical coordinates (=lon=, =lat=) over the /logical/ coordinates
(=rlon=, =rlat=) may damage the plot.  This is because =zbcont= relies
on the feature of ~matplotlib~ ~contour~ method.  It is expected that
using ~tricontour~ method instead would resolve the problem, which is
reserved for future developments.

It is also possible than an data array have only non-dimension
coordinates corresponding to its dimension.  This may happen when
a MIROC tripolar field is opened:
: >>> :
: >>> TO
: <xarray.DataArray 'TO' (record: 12, OCDEPT63: 1, OCLATTPT256: 256,
:                         OCLONTPT360: 360)> Size: 4MB
: [1105920 values with dtype=float32]
: Coordinates:
:     OCLONTPT360  (OCLATTPT256, OCLONTPT360) float64 737kB ...
:     OCLATTPT256  (OCLATTPT256, OCLONTPT360) float64 737kB ...
:   * OCDEPT63     (OCDEPT63) float64 8B 0.0
:   * record       (record) object 96B 2001-01-16 12:00:00 ... 2001-12-16 12:00:00
In the above case, the coordinates =OCLONTPT360=, =OCLATTPT256= have
the same names as array's dimensions, and there are no 1-d
coordinates corresponding to both dimensions.
Plotting are automatically performed with non-dimension coordinates
even without =--plot= arguments.
In order to plot using the array dimension, you need to run =zbcont=
with =--no-decode_coords= arguments.

There is a deficiency around non-dimension coordinate plotting.
The number of dimensions to alternate must match with that of the
original dimensions.  In other words, a data array with following
shape cannot be plotted:
: >>> bad_array
: <xarray.DataArray 'bad_array' (serial:100)> Size: 1kB
: Coordinates:
:     lon      (serial) float64 1kB ...
:     lat      (serial) float64 1kB ...
Logically bad_array is one dimension (=serial=) array, but
two-dimension coordinates are assigned for each gridpoints, which
forms physically a two-dimension field.  Their number of dimensions do
not matches, thus =zbcont= cannot handle this array.

Improving this feature is definitely a next target of development for
a coming release.

**** (experimental) map overlay (=--map=, =-m=)
: % zbcont -m [LAT,LON,]LETTERS
: % zbcont -m [LAT,LON,]LETTERS
: % zbcont -m [LAT,LON,]FEATURE[,FEATURE...]
: % zbcont -m [LAT,LON,]FEATURE[/COLOR][+ALPHA][,FEATURE....]
| letter | string | feature                               |
|--------+--------+---------------------------------------|
| c      | coast  | add coastline                         |
| o      | ocean  | fill ocean                            |
| l      | land   | fill land                             |
| b      | border | add borders                           |
| r      | river  | add rivers                            |
| L      | lake   | add lakes                             |
***** examples
: % zbcont -m c  .....           # add coastline
: % zbcont -m ol                 # fill ocean and land
: % zbcont -m river,lake         # add rivers and lakes
: % zbcont -m l+0.3              # land, filled with default color and alpha=0.3
: % zbcont -m l/brown            # land, filled with brown
: % zbcont -m l/brown+0.3        # land, filled with brown and alpha=0.3
: % zbcont -m l/brown+0.3,o/blue+0.3 # land, filled with brown and alpha=0.3
:                                    # ocean, filled with blue and alpha=0.3
: % zbcont -m -3,-1,land         # set latitude/longitude coordinates as (-3,-1)

**** (experimental) projection (=--projection=, =-P=)
: % zbcont -P PROJECTION[+LON[+LAT[+HEIGHT]]]
| string                 | projection          | parameters                          |
|------------------------+---------------------+-------------------------------------|
| m mercator             | Mercator            | central longitude                   |
| w mo mollweide         | Mollweide           | central longitude                   |
| nps northpolarstereo   | NorthPolarStereo    | central longitude                   |
| sps southpolarstereo   | SouthPolarStereo    | central longitude                   |
| np nearsideperspective | NearsidePerspective | central longitude, latitude, height |
| g orthographic         | Orthographic        | central longitude, latitude         |
| h hammer               | Hammer              | central longitude                   |
| pc platecarree         | PlateCarree         | central longitude                   |
***** examples
: % zbcont -Ppc+135 FILE    # central longitude on 135E.

***** Known problems, tips and tricks
****** =PlateCarree=
Longitude locator may fail to put the label beyond the longitude span
of original data-array.  For example, when the span of a data array is
-300.0:60.0, the labels beyond 60 degree are not shown with default parameters.
Shifting of the central longitude may help to recover the labels:
: % zbcont -Ppc+1 datafile     # Works as expected
: % zbcont -Ppc-1 datafile     # Works as expected
: % zbcont -Ppc datafile       # Strange
: % zbcont -Ppc+0.9 datafile   # Strange
: % zbcont -Ppc-0.9 datafile   # Strange
Need some trials to detect the least amount of shift.
#+CAPTION: Demonstration of PlateCarree (=zbcont -Ppc+1 datafile=).
#+NAME:   fig:demo_PlateCarree-1.png
[[./doc/demo_PlateCarree-1.png]]
#+CAPTION: Demonstration of PlateCarree (=zbcont -Ppc datafile=).
#+NAME:   fig:demo_PlateCarree-0.png
[[./doc/demo_PlateCarree-0.png]]
#+CAPTION: Demonstration of PlateCarree (=zbcont -Ppc+0.9 datafile=).
#+NAME:   fig:demo_PlateCarree-2.png
[[./doc/demo_PlateCarree-2.png]]

This problem is one of the next targets to fix.
****** =NorthPolarStereo= =SouthPolarStereo=
Strange domain may be chosen to plot without manual limiting of plot region.
Anyway polar stereographic projections are special method to show only
the polar regions, limiting of latitude range is generally a good idea.
: % zbcont -Pnps datafile      # Strange plot domain influenced by original array
: % zbcont -Psps datafile      # Strange
: % zbcont -Pnps -Dlatitude/30.0:90.0 datafile     # Works as expected
: % zbcont -Psps -Dlatitude/-90.0:-30.0 datafile   # Works as expected
Of course a valid coordinate name should be used (=latitude=, in this
case).
#+CAPTION: Demonstration of NorthPolarStereo (=zbcont -Pnps datafile=).
#+NAME:   fig:demo_NorthPolarStereo-0.png
[[./doc/demo_NorthPolarStereo-0.png]]

#+CAPTION: Demonstration of NorthPolarStereo (=zbcont -Pnps -Dlatitude/30.0:90.0 datafile=).
#+NAME:   fig:demo_NorthPolarStereo-1.png
[[./doc/demo_NorthPolarStereo-1.png]]

#+CAPTION: Demonstration of SouthPolarStereo (=zbcont -Psps datafile=).
#+NAME:   fig:demo_SouthPolarStereo-0.png
[[./doc/demo_SouthPolarStereo-0.png]]

#+CAPTION: Demonstration of SouthPolarStereo (=zbcont -Psps -Dlatitude/-90.0:-30.0 datafile=).
#+NAME:   fig:demo_SouthPolarStereo-1.png
[[./doc/demo_SouthPolarStereo-1.png]]

Color option for the feature OCEAN may not work as expected for
=NorthPolarStereo=: the color is filled globally, not only over the ocean.
A workaround to avoid this is to add the feature LAND *after* OCEAN
option (the order is significant)
: % zbcont -Pnps -mocean+blue,land datafile     # Works.
: % zbcont -Pnps -mland,ocean+blue datafile     # Not works


****** =Orthographic=
Strange domain may be chosen to plot without manual limiting of plot region.
Longitude span to work depends on the central longitude
of the projection.  As far as tried, at least 90 degree spaces are
required from the central longitude for both limits.
: % zbcont -Pg datafile                                 # Strange
: % zbcont -Pg -Dlongitude/-180.0:180.0 datafile
: % zbcont -Pg+90 -Dlongitude/-180.0:180.0 datafile
: % zbcont -Pg+100 -Dlongitude/-180.0:180.0 datafile    # Strange (insufficient spaces)
: % zbcont -Pg+100 -Dlongitude/0.0:360.0 datafile
#+CAPTION: Demonstration of Orthographic (=zbcont -Pg datafile=).
#+NAME:   fig:demo_Orthographic-0.png
[[./doc/demo_Orthographic-0.png]]

#+CAPTION: Demonstration of Orthographic (=zbcont -Pg -Dlongitude/-180.0:180.0 datafile=).
#+NAME:   fig:demo_Orthographic-1.png
[[./doc/demo_Orthographic-1.png]]

#+CAPTION: Demonstration of Orthographic (=zbcont -Pg+90 -Dlongitude/-180.0:180.0 datafile=).
#+NAME:   fig:demo_Orthographic-2.png
[[./doc/demo_Orthographic-2.png]]

#+CAPTION: Demonstration of Orthographic (=zbcont -Pg+100 -Dlongitude/-180.0:180.0 datafile=).
#+NAME:   fig:demo_Orthographic-3.png
[[./doc/demo_Orthographic-3.png]]

#+CAPTION: Demonstration of Orthographic (=zbcont -Pg+100 -Dlongitude/0.0:360.0 datafile=).
#+NAME:   fig:demo_Orthographic-4.png
[[./doc/demo_Orthographic-4.png]]

****** =NearsidePerspective=
Strange domain may be chosen to plot (sometimes even the program
aborts with an error) when the central *latitude* is specified.
: % zbcont -Pnp datafile        # Works
: % zbcont -Pnp+0+30 datafile   # Strange
: % zbcont -Pnp+0+30 -Dlongitude/-180.0:180.0 -Dlatitude/-90.0:90.0 datafile  # Works
: % zbcont -Pnp+90+10 datafile  # Aborts
: :
: shapely.errors.GEOSException: IllegalArgumentException: point array must contain 0 or >1 elements:

#+CAPTION: Demonstration of NearsidePerspective (=zbcont -Pnp datafile=).
#+NAME:   fig:demo_NearsidePerspective-0.png
[[./doc/demo_NearsidePerspective-0.png]]

#+CAPTION: Demonstration of NearsidePerspective (=zbcont -Pnp+0+30 datafile=).
#+NAME:   fig:demo_NearsidePerspective-1.png
[[./doc/demo_NearsidePerspective-1.png]]

#+CAPTION: Demonstration of NearsidePerspective (=zbcont -Pnp+0+30 -Dlongitude/-180.0:180.0 -Dlatitude/-90.0:90.0 datafile=).
#+NAME:   fig:demo_NearsidePerspective-2.png
[[./doc/demo_NearsidePerspective-3.png]]

****** =Mercator=
Strange domain may be chosen to plot.  Need manual adjustment of
the longitude range *and* the central longitude accordingly.
Longitude span should be slightly larger than 180 degree at both side
for the global view.
: % zbcont -Pm datafile                                 # Strange
: % zbcont -Pm -Dlongitude/-180.0:180.0 datafile        # Still strange
: % zbcont -Pm -Dlongitude/-180.1:180.1 datafile        # Works
: % zbcont -Pm+30 -Dlongitude/-150.1:210.1 datafile     # Works

#+CAPTION: Demonstration of Mercator (=zbcont -Pm datafile=).
#+NAME:   fig:demo_Mercator-0.png
[[./doc/demo_Mercator-0.png]]

#+CAPTION: Demonstration of Mercator (=zbcont -Pm -Dlongitude/-180.0:180.0 datafile=).
#+NAME:   fig:demo_Mercator-1.png
[[./doc/demo_Mercator-1.png]]

#+CAPTION: Demonstration of Mercator (=zbcont -Pm -Dlongitude/-180.1:180.1 datafile=).
#+NAME:   fig:demo_Mercator-2.png
[[./doc/demo_Mercator-2.png]]

****** =Mollweide=, =Hammer=
Strange domain may be chosen to plot, and any workaround solution to
recover the domain have not yet been found.

**** output (=--output=, =-o=)
: --output=<filename>
Specification of output argument switches the =zbcont= execution to
batch (non-interactive) mode.  All the slices, which may be limited by
=--dimensions= arguments, are saved.  Filenames are possibly renamed
to avoid duplicates.  If only one slice is saved, then =<filename>= is
used as it is.  If more than one slices are saved, outputs are renamed
as =<filename base>_<n>.<filename suffix>= where =<n>= is number count
from 0.  The number part may be padded by 0, where the number of
digits are chosen automatically according to number of slices.  If
less than 10 then 0 to 9, less than 100 then 00 to 99, and so on.

File types are determined by suffix.  ~Matplotlib~ accepts several
formats including pdf, ps, eps, png, jpg, etc.

For pdf output, a special mode can be activated to save all the slices
in single pdf file.  In this case, =<filename>= is adopted as it is.
This is default behavior and it is disabled by using =--multi-pdf=
argument.

If you want to run interactive mode and manually select the slices to
save, run =zbcont= with =--interactive= argument.

: % zbcont --output hoge.pdf --interactive

In this case, the selected figures (by key =p=) are saved in the
output.  In this case, the first slice is saved with =<filename>= as
it is, and those from the second slice are save with automatic number
suffix, without zero-padding (i.e., 0 to 9, 10 to 99, 100 to 999 ...).

If output is not specified in the command line argument, the mode is
unconditionally interactive mode.  You can still save selected slices
manually.  In this case, filenames are generated automatically as the
format like =zbtFigure-<g>_<n>.png= where =<g>= is chosen not to
overwrite existing files.  There is no command-line option to choose
other formats except for png.

If =<filename>= or its variation of integer suffix already exists,
then =zbcont= would aborts.  You can force to overwrite the existing
files using =-force= argument.

**** (pdf output only) =--multi-pdf=, =--no-multi-pdf=
**** interactive (=--interactive=, =-i=)
**** force (=--force=)

*** Coordinate category
Array coordinates are categorized into four.
For example, slice attributes of an array of 5 dimension
are shown on the terminal such as:
: (1) 0:T2 <0:T2> [[3], (0), :, 2, 10:20]
where the last part surrounded by brackets are coordinate and category.

The coordinates which contain colon is /plot-coordinates/.  For
contour plots there are always two /plot-coordinates/ (in this case 2nd
and 4th), either of which is the horizontal and the other the vertical
coordinate in the figure.

Single number coordinate (=2=) is /iterate-coordinate/.  These
coordinate can be incremented or decremented by key or mouse.

Single number surrounded by parenthesis (=(0)=) is
/anchor-coordinate/.  This coordinate is temporally fixed to be
excluded from the iteration.  An anchor coordinate may be toggled
to/from an iterate coordinate.

Single number surrounded by brackets (=[3]=) is /limited-coordinate/,
which cannot be changed during the execution.

For contour plots, there can be any number of iterate-, anchor-,
limited-coordinate.

*** Marking of multiple figures to control at once
More than one figures can be plotted by duplication or creation.
They are plotted independently to each other, while marking some or
all of the figures enables to control at the same time.

This feature is still buggy, and not all the controls,
possibly naturally expected, are synchronized.

*** runtime controls
**** keyboard control
The following keys works by default when the focus is on the plot
window:

- =q= :: quit
- =Q= :: quit all
- =D= :: duplicate the figure
- =ctrl+n= :: new fresh figure window
- =ctrl+r= :: duplicate the figure and close old
- space :: next slice through the sequence
- backspace :: previous slice through the sequence
- right :: next slice within the variable
- left :: previous slice within the variable
- =v= :: next variable through the sequence
- =V= :: next variable within file
- =f= :: next file
- =1= =2= =3= =4= :: turn the inner 0, 1, 2, 3 index to previous/next slice
- =9= =8= =7= =6= :: turn the outer 0, 1, 2, 3 index to previous/next slice
- =5= :: toggle turning direction
- =m= :: toggle mark the figure window
- =U= :: unmark all the figures
- =M= :: toggle all the marks
- =p= :: save the figure image
- =#= :: reverse horizontal plot-coordinate
- =%= :: reverse vertical plot-coordinate
- =:= :: transpose plot-coordinates
- =]= :: next plot-coordinate permutation
- =[= :: previous plot-coordinate permutation
- =)= :: next anchor-coordinate permutation
- =(= :: previous anchor-coordinate permutation
- =!= :: clear all the anchors
- =w= :: view entire domain
- =+= :: enlarge the figure geometry
- =-= :: shrink the figure geometry
- =,= :: reset the figure geometry
- === :: synchronize the figure geometry among marks
- =.= :: redraw the figure
- =0= :: rewind the figure slice
- =C= :: next colormap
- =N= :: next color norm
- =i= :: short figure information on the terminal
- =I= :: long figure information on the terminal

Some keys work on multiple marked figures at once.

**** mouse control
Mouse controls are also prepared.  The functions depend on the
location where the pointer is.

| location      | event        | control                              |
|---------------+--------------+--------------------------------------|
| figure        | left click   | plot-coordinate (keep horizontal)    |
|               | right click  | plot-coordinate (keep vertical)      |
|               | middle click | plot-coordinate (both permuted)      |
|               | scroll       | next/previous slice                  |
|---------------+--------------+--------------------------------------|
| axis label    | left click   | next coordinate (keep the other)     |
|               | right click   | previous coordinate (keep the other) |
|               | middle click | transpose coordinate                 |
|---------------+--------------+--------------------------------------|
| figure spin   | left click   | section at point                     |
|               | right click  | next norm for the axis               |
|               | middle click | reverse the direction                |
|---------------+--------------+--------------------------------------|
| colorbar      | left click   | next colormap with the current group |
|               | right click  | next colormap group                  |
|               | middle click | reverse the colormap direction       |
|---------------+--------------+--------------------------------------|
| colorbar spin | middle click | lock the colorbar range              |
|               | right click  | next norm for the colorbar           |
|---------------+--------------+--------------------------------------|
| contour info  | middle click | lock the contour spec                |

**** (not implemented) terminal control
*** customization
Customization can be performed with =zbtrc.toml=.
Need document.

* Description of TOUZA/Zbt package
** ~zbt.libtouza~ - low-level interface on TOUZA(/Nio) library
*** Requirement
A shared library of TOUZA (version 1.14.3 or later) must be
installed somewhere the module can find.
If you encounter something like following message, it means that the
module fails to find the library.
: Cannot load touza library.  Setting TOUZA_LIB environment may help.
: Traceback (most recent call last):
: :
: :
: AttributeError: /usr/.....so: undefined symbol: _touza

In this case, you must define the environment variable =TOUZA_LIBRARY=
to define the path to the library.
: export TOUZA_LIBRARY=/SOMEWHERE/lib/libtouza.so
** ~zbt.dsnio~ - TOUZA/Nio dataset module, to emulate ~netcdf4-python~
This is minimum emulation of Dataset class in netcdf4-python for
GTOOL3 (TOUZA/Nio) format file, based on ~zbt.libtouza~ module.
*** Usage
*** Limitation (some are reserved to be improved )
- Only file reading is implemented (file writing is reserved for
  future development).
- Only c-style array indexing is implemented.  It means that the time
  series of a 3 dimension variable is represented as =V[0:NT, 0:NZ, 0:NY, 0:NX]=.
- Due to much freedom originating from the GTOOL3 format policy,
  automatic conversion to a dataset might be different from what the
  user expects.
- For a compromise of simple transformation from GTOOL3 format file to
  something like netCDF4, all the variables share the record
  dimension among a group generated by ~TouzaNioDataset~ class,
  except for root (suite) class.
- Slice accesses of array at file reading are partially implemented:
  Any step except for 1 does not work correctly.
  This limitation is only at file read, thus, the following works,
  : ds = TouzaNioDataset('gtool-file.dat')
  : v = ds['var'][2:5]  # read file and set v slice without step
  : print(v[::2] )      # slicing with step
  while the following not,
  : ds = TouzaNioDataset('gtool-file.dat')
  : v = ds['var']     # file reading is not performed
  : print(v[2:5:2] )  # read file and set v slice, which will fail.
- =TouzaNioCoDataset= class does not parse time coordinate.
** ~zbt.xrnio~ - ~xarray~ backends of zbt.dsnio module
** ~zbt.plot~ - Plot and layout methods
** ~zbt.control~ - Iteration control on xarray-like data structure
** ~zbt.config~ - class attribute configuration layer
* Random notes
** Tips of ~matplotlib~ and ~xarray~
*** Interactive adjustment of colormap range
Interactive adjustment is controlled on =matplotlib/colorbar.py= as:
: # Don't navigate on any of these types of mappables
: if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
:         isinstance(self.mappable, contour.ContourSet)):
:     self.ax.set_navigate(False)
which means that it is disabled when norm is either BoundaryNorm
(discrete) or NoNorm.  Their definition would be undefined beyond the
initial ranges, therefore adjustment may not work as expected.
You can try with ~ax.set_navigate(True)~, which may show strange
behavior.  You can achieve similar interactive effects on discrete
colormaps with using, e.g., PowerNorm(1.0).

cf: [[https://matplotlib.org/stable/gallery/images_contours_and_fields/colormap_interactive_adjustment.html][matplotlib example]]
* Acknowledgements
TOUZA/Zbt has been developed after much trials of GTOOL3 python
implementation by three great predecessors: Ogochi Koji san, Suzuki
Tatsuo san, Komuro Yoshiki san.  It is coded from scratch, however,
most ideas adopted and/or abandoned on TOUZA/Zbt are definitely
originated from their trials.  The maintainer really appreciates them
who share their own developments.

* Copyright and license
Copyright 2024,2025 Japan Agency for Marine-Earth Science and Technology
Licensed under the Apache License, Version 2.0
  (https://www.apache.org/licenses/LICENSE-2.0)

#  LocalWords:  TOUZA Zbt SAITO Fuyuki saitofuyuki jamstec jp zbt Nio
#  LocalWords:  libtouza touza Traceback AttributeError dsnio netcdf
#  LocalWords:  GTOOL NX netCDF TouzaNioDataset ds gtool dat xrnio xr
#  LocalWords:  TouzaNioCoDataset xarray backends GTAX ngtls GLON SFC
#  LocalWords:  GGLA matplotlib pyplot plt xds kB GTAXLOC coords sel
#  LocalWords:  FrozenMappingWarningOnValuesAccess DataArray dtype cd
#  LocalWords:  fbc jmz nctcdf pkgconfig env LD LibTouzaNio zbcont py
#  LocalWords:  PYTHONPATH ctrl contourf pcolormesh imshow CMAP MIROC
#  LocalWords:  Colormap viridis README init pycache config backend
#  LocalWords:  xrNioBackendEntrypoint zxr xrNioDataArray nio recdim
#  LocalWords:  IDFM CDATE CDATA NumPy unmark pdf hoge zbtrc toml za
#  LocalWords:  nc debian cftime datetime numpy libdir URY CMIP ns sw
#  LocalWords:  xrNioDataset nonstd RuntimeError ngtick nds znio DSET
#  LocalWords:  proleptic gregorian noleap julian dbg MSIGN fb ol nps
#  LocalWords:  cartopy mercator mollweide Mollweide northpolarstereo
#  LocalWords:  NorthPolarStereo sps southpolarstereo np pc ppc li sl
#  LocalWords:  SouthPolarStereo nearsideperspective platecarree RdBu
#  LocalWords:  NearsidePerspective PlateCarree colormap mappables sy
#  LocalWords:  isinstance BoundaryNorm NoNorm mappable ContourSet ps
#  LocalWords:  colormaps PowerNorm symlog twoslope Colorbars atanh
#  LocalWords:  colorbar fortran PiYG cividis YlOrBr YlOrRd OrRd PuRd
#  LocalWords:  RdPu BuPu GnBu PuBu YlGnBu PuBuGn BuGn YlGn yarg PRGn
#  LocalWords:  Wistia afmhot BrBG PuOr RdGy RdYlBu RdYlGn coolwarm
#  LocalWords:  bwr hsv qual gnuplot CMRmap cubehelix brg nipy ncar
#  LocalWords:  cmap sym asinh arcsinh eps png jpg zbtFigure nd th fn
#  LocalWords:  Ogochi Koji san Tatsuo Komuro Yoshiki tripolar OCDEPT
#  LocalWords:  OCLONTPT OCLATTPT gridpoint basenames tri tas rlon
#  LocalWords:  rlat lon datafile tricontour stereographic Pnps Psps
#  LocalWords:  Dlatitude Dlongitude Pnp IllegalArgumentException
#  LocalWords:  gridpoints mocean mland
